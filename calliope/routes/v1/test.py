from http.client import HTTPException
import os

from calliope.inference.engines.runway import runway_retrieve_video
import httpx
from fastapi import APIRouter, Depends
from fastapi.security.api_key import APIKey

from calliope.inference.text_to_video import image_and_text_to_video_file_inference
from calliope.models import FramesRequestParamsModel
from calliope.storage.config_manager import (
    get_sparrow_story_parameters_and_keys,
)
from calliope.storage.state_manager import (
    get_sparrow_state,
)
from calliope.tables.model_config import ModelConfig
from calliope.utils.authentication import get_api_key
from calliope.utils.id import create_cuid


router = APIRouter(prefix="/v1/test", tags=["test"])


@router.post("/video/")
async def request_post_video_create(
    prompt_image_file: str,
    prompt_text: str,
    model_name: str = "runway-gen-4-turbo",
    api_key: APIKey = Depends(get_api_key),
):
    print(f"test/video: '{prompt_image_file}', '{prompt_text}'")
    """Test endpoint for video generation."""
    # Get model config
    model_config = await ModelConfig.objects().where(
        ModelConfig.slug == model_name
    ).first().run()

    request_params = FramesRequestParamsModel(client_id="test")
    client_id = request_params.client_id
    sparrow_state = await get_sparrow_state(client_id)

    (
        _,
        keys,
        _,
    ) = await get_sparrow_story_parameters_and_keys(request_params, sparrow_state)

    if not model_config:
        raise HTTPException(status_code=404, detail="Model configuration not found")

    # Get API keys
    # keys = KeysModel(runway_api_key=os.environ.get("RUNWAY_API_KEY"))

    # Generate unique output filename
    output_video_filename = f"media/test_video_{create_cuid()}.mp4"

    # Generate video
    timeout = httpx.Timeout(180.0)
    async with httpx.AsyncClient(timeout=timeout) as httpx_client:
        result = await image_and_text_to_video_file_inference(
            httpx_client=httpx_client,
            prompt_image_file=prompt_image_file,
            prompt_text=prompt_text,
            output_video_filename=output_video_filename,
            model_config=model_config,
            keys=keys,
        )

    # Return video URL
    if result:
        return {"video_url": f"/media/{os.path.basename(result)}"}
    else:
        raise HTTPException(status_code=500, detail="Video generation failed")


@router.get("/video/")
async def request_get_video_get(
    task_id: str,
    api_key: APIKey = Depends(get_api_key),
):
    print(f"test/video: '{task_id}'")
    """Retrieve a video generated by a prior task."""

    request_params = FramesRequestParamsModel(client_id="test")
    client_id = request_params.client_id
    sparrow_state = await get_sparrow_state(client_id)

    (
        _,
        keys,
        _,
    ) = await get_sparrow_story_parameters_and_keys(request_params, sparrow_state)

    # Get API keys
    # keys = KeysModel(runway_api_key=os.environ.get("RUNWAY_API_KEY"))

    # Generate unique output filename
    output_video_filename = f"media/test_video_{create_cuid()}.mp4"

    # Generate video
    timeout = httpx.Timeout(20.0)
    async with httpx.AsyncClient(timeout=timeout) as httpx_client:
        result = await runway_retrieve_video(
            httpx_client=httpx_client,
            task_id=task_id,
            output_video_filename=output_video_filename,
            keys=keys,
        )

    # Return video URL
    if result:
        return {"video_url": f"/media/{os.path.basename(result)}"}
    else:
        raise HTTPException(status_code=500, detail="Video generation failed")
